 N [G]0.0 [H] X Y Z [U] [V] [W] [P] [Q] [R] [I] [J] [K] : G1893

;//
;// G1893   N<phase> [G<tip_radius>] [H<cylinder_radius>]
;//         X<ax> Y<ay> Z<az>    (N1, N2, N3)
;//         U<bx> V<by> W<bz>    (N1, N2, [N3])
;//         P<cx> Q<cy> R<cz>    (N1)
;//        [I<dx> J<dy> K<dz>    (N1)]
;//
;// Maps a cylinder given a set of 6(7) points and radius (or 7(8) points and
;// no radius).  Cylinder and tool tip radii signs depend on surface side
;// (outside or inside).
;// Multiple calls with ascending values of N have to be made.
;//
;// -- N1 --
;// Maps Z-normal flat surface given 3(4) points.
;//
;// uf_a<1..3><1..3> is initialized so that frame Z is parallel to AB ^ AC
;// (or AD ^ BC in case of 4 points).
;// Frame X is chosen so that it's normal to AB.
;// uf_o<1..3> is set to A (or (A+B+C+D)/4 in case of 4 points).
;//
;// -- N2 --
;// Maps Y-normal section plane, parallel to frame Z axis, given 2 points.
;// Requires a previous call to N1.
;//
;// uf_a<1..3><1..3> is rotated around its Z so that frame X is normal to the
;// Z-normal plane projection of AB.  Frame is finalized.
;// uf_o<1..3> position along frame Y axis is finalized.
;//
;// -- N3 --
;// Maps X-normal section plane given 1 point and radius, or 2 points and no
;// radius.  In case of no radius, points must have same signed distance from
;// Y-normal plane.  In case of radius, A point must be on the Y-normal section
;// plane.
;// Requires a previous call to N2.
;//
;// uf_o<1..3> contains finalized origin (flat surface center).
;//

DBL ax = VA23, ay = VA24, az = VA25
DBL bx = VA20, by = VA21, bz = VA22
DBL cx = VA15, cy = VA16, cz = VA17
DBL dx = VA8 , dy = VA9 , dz = VA10
DBL tip_rad = VA6
DBL cyl_rad = VA7
DBL phase = VA13

DBL abx, aby, abz
DBL acx, acy, acz
DBL d1, d2
DBL d

JMPF phase

N1

IF (!(VALID(ax) && VALID(ay) && VALID(az))) ERROR(55)
IF (!(VALID(bx) && VALID(by) && VALID(bz))) ERROR(55)
IF (!(VALID(cx) && VALID(cy) && VALID(cz))) ERROR(55)

IF (VALID(dx) || VALID(dy) || VALID(dz)) THEN
    IF (!(VALID(dx) && VALID(dy) && VALID(dz))) ERROR(55)
    ;//ab = d - a
    abx = dx - ax
    aby = dy - ay
    abz = dz - az

    ;//ac = c - b
    acx = cx - bx
    acy = cy - by
    acz = cz - bz
ELSE
    ;//ab = b - a
    abx = bx - ax
    aby = by - ay
    abz = bz - az

    ;//ac = c - a
    acx = cx - ax
    acy = cy - ay
    acz = cz - az
ENDIF
;//uf_a_3 = norm(ab ^ ac)
uf_a13 = aby * acz - abz * acy
uf_a23 = abz * acx - abx * acz
uf_a33 = abx * acy - aby * acx

d = SQRT(uf_a13 * uf_a13 + uf_a23 * uf_a23 + uf_a33 * uf_a33)

IF (d < 0.001) ERROR(38) ;//divide by zero

uf_a13 = uf_a13 / d
uf_a23 = uf_a23 / d
uf_a33 = uf_a33 / d

IF (VALID(dx) || VALID(dy) || VALID(dz)) THEN
    ;//uf_o_ = a
    uf_o1 = (ax+bx+cx+dx) / 4
    uf_o2 = (ay+by+cy+dy) / 4
    uf_o3 = (az+bz+cz+dz) / 4
ELSE
    ;//uf_o_ = a
    uf_o1 = ax
    uf_o2 = ay
    uf_o3 = az
ENDIF
;//uf_o_' = uf_o_ - tip_rad * uf_a_3
uf_o1 = uf_o1 - tip_rad * uf_a13
uf_o2 = uf_o2 - tip_rad * uf_a23
uf_o3 = uf_o3 - tip_rad * uf_a33

tip_rad = 0.0

;//a' = a - (b-a)
ax = 2*ax - bx
ay = 2*ay - by
az = 2*az - bz

N2

IF (!(VALID(ax) && VALID(ay) && VALID(az))) ERROR(55)
IF (!(VALID(bx) && VALID(by) && VALID(bz))) ERROR(55)

;//ab = b - a
abx = bx - ax
aby = by - ay
abz = bz - az

;//uf_a_1 = norm(ab ^ uf_a_3)
uf_a11 = aby * uf_a33 - abz * uf_a23
uf_a21 = abz * uf_a13 - abx * uf_a33
uf_a31 = abx * uf_a23 - aby * uf_a13

d = SQRT(uf_a11 * uf_a11 + uf_a21 * uf_a21 + uf_a31 * uf_a31)

IF (d < 0.001) ERROR(38) ;//divide by zero

uf_a11 = uf_a11 / d
uf_a21 = uf_a21 / d
uf_a31 = uf_a31 / d

;//uf_a_2 = uf_a_3 ^ uf_a_1
uf_a12 = uf_a23 * uf_a31 - uf_a33 * uf_a21
uf_a22 = uf_a33 * uf_a11 - uf_a13 * uf_a31
uf_a32 = uf_a13 * uf_a21 - uf_a23 * uf_a11

;//d1 = (a - uf_o_) * uf_a_2
d1 = (ax - uf_o1) * uf_a12 + (ay - uf_o2) * uf_a22 + (az - uf_o3) * uf_a32

;//d2 = (b - uf_o_) * uf_a_2
d2 = (bx - uf_o1) * uf_a12 + (by - uf_o2) * uf_a22 + (bz - uf_o3) * uf_a32

d = (d1 + d2) / 2

;//uf_o_' = uf_o_ + d * uf_a_2
uf_o1 = uf_o1 + d * uf_a12
uf_o2 = uf_o2 + d * uf_a22
uf_o3 = uf_o3 + d * uf_a32

tip_rad = 0.0

cyl_rad = QNAN()

N3

IF (!(VALID(ax) && VALID(ay) && VALID(az))) ERROR(55)

;//d1 = (a - uf_o_) * uf_a_1
d1 = (ax - uf_o1) * uf_a11 + (ay - uf_o2) * uf_a21 + (az - uf_o3) * uf_a31

IF (VALID(cyl_rad)) THEN
    IF (VALID(bx) || VALID(by) || VALID(bz)) ERROR(55)
    d = d1 - tip_rad + cyl_rad
ELSE
    IF (!(VALID(bx) && VALID(by) && VALID(bz))) ERROR(55)
    ;//d2 = (b - uf_o_) * uf_a_1
    d2 = (bx - uf_o1) * uf_a11 + (by - uf_o2) * uf_a21 + (bz - uf_o3) * uf_a31

    d = (d1 + d2) / 2
ENDIF

;//uf_o_' = uf_o_ + d * uf_a_1
uf_o1 = uf_o1 + d * uf_a11
uf_o2 = uf_o2 + d * uf_a21
uf_o3 = uf_o3 + d * uf_a31

RET
