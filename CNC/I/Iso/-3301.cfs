 [X]0 [Y]0 [U]0 [V]0 : G2301

ERROR(55); PLEASE SWITCH TO NEW CYCLES

;// tubeCalibration
;//
;// uses data from G2292 and from part-program
;//     DBL xs ...
;//     DBL acquireX, ...
;// simulation data
;//     DBL simErrorX, ...
;// size information is output
;//     DBL sizeX, ...
;//
;// *** IMPORTANT ***
;// 1) pipes must be quadrant-symmetric
;// 2) coordinates from G2292 MUST be already sorted
;//
DBL minFlatness = 2*border + minSide
DBL u[4], v[4], rnd
DBL isFlat[4]
DBL fSimul = %cn[WHO()].rc[0].21
DBL fGraph = %cn[WHO()].pc[14].25
DBL isAngleDone
DBL x, y, z, c
;// DEBUG: force angle probing until specific side(s) [0(disable)..4]
DBL cycleDebug = 0
DBL touch_epsilon
DBL p[4]
DBL pLj, pRj, pLi, pRi, pC
DBL saveF = XGET("@F")
DBL dst
DBL tmp[3]
DBL Vacq_x, Vacq_y, Vacq_z
;// Calculated errors
DBL errorX, errorY, errorZ
DBL errorA, errorB
DBL acquireX = VA23
DBL acquireY = VA24
DBL acquireU = VA20
DBL acquireV = VA21
DBL sav_gTravT
DBL z_abs
DBL DistFromPiece = 3   ; 3 mm distance from piece
DBL touch_enable = 1
DBL gTouchMode = 1
DBL gRegolMode = 1
DBL piercing_mode = 0
DBL hix = 0
DBL tx, ty, tz
DBL ti, tj, tk
DBL vectorSelect =  1   ;//1 = tool, 2 = surface, 6 = Z

IF( %LSRPlcOp0.23 == 1 ) RET            ; function disable
IF( ls_stateping != 0 ) ERROR(55)       ; Error if not G840 L0
IF (fSimul) RET

IF( %gIso[26] == 3 ) THEN               ; Code to identify the triangle
    G2302 X(acquireX) Y(acquireY) U(acquireU) V(acquireV)
ENDIF
IF( %gIso[26] == 3 ) RET               ; Code to identify the triangle

IF( glbIsPolygon ) RET

SYN
IF( (!%gPlc0.29) && (!%PlcOp0.2) ) THEN ; If not 1000.pgm and not DRYRUN
    IF( %M107.1 ) M496  ;Disable GASES
ENDIF

sav_gTravT = gTravT

;// select plane
IF (isTubeY == 0) THEN
    rnd = xr
    u[0] = ys + rnd
    u[1] = ys + rnd
    v[0] = zs + rnd
    v[3] = zs + rnd
    u[2] = ye - rnd
    u[3] = ye - rnd
    v[2] = ze - rnd
    v[1] = ze - rnd
ELSE
    rnd = yr
    u[0] = zs + rnd
    u[1] = zs + rnd
    v[0] = xs + rnd
    v[3] = xs + rnd
    u[2] = ze - rnd
    u[3] = ze - rnd
    v[2] = xe - rnd
    v[1] = xe - rnd
ENDIF

IF (u[3] < (u[0] - 0.002)) ERROR(55)
IF (v[0] > (v[1] + 0.002)) ERROR(55)
IF (u[1] > (u[2] + 0.002)) ERROR(55)
IF (v[2] < (v[3] - 0.002)) ERROR(55)

;// make sure it's quadrant-symmetric
IF (ABS(u[3] + u[0]) > 0.02) ERROR(55)
IF (ABS(v[0] + v[1]) > 0.02) ERROR(55)
IF (ABS(u[1] + u[2]) > 0.02) ERROR(55)
IF (ABS(v[2] + v[3]) > 0.02) ERROR(55)

;// shape flatness (bottom, left, top, right)
isFlat[0] = u[3] > (u[0] + minFlatness)
isFlat[1] = v[0] < (v[1] - minFlatness)
isFlat[2] = u[1] < (u[2] - minFlatness)
isFlat[3] = v[2] > (v[3] + minFlatness)

;// Meaning of _s, _e, u[] v[] coordinates and isFlat[] side flags
;//
;//    s     e
;// v  :  2  :            pipe
;// ^   ----- .. e        axis
;// |  |1   2|           X or Y
;// | 1|     |3          :    :
;// |  |0   3|      u = (Y or Z)
;// |   ----- .. s       :    :
;// |     0         v = (Z or X)
;// +--------> u

MSGOUT "Tube calibration in progress..."

G172 T(spindle_id) H1 D(tool_id) E(table_id)
G153 G0 Z(lift)

; cut_type is the the reference to understand if there is a calibration for 2D or 3D
IF (cut_type == 2) dst = 2
IF (cut_type == 3) dst = 3

SYN
; Ripristino tabella 2 o 3 con i dati della tabella principale
%tab[dst].t_ttab.t_oart.t_dX  = %tab[table_id].t_ttab.t_oart.t_dX
%tab[dst].t_ttab.t_oart.t_dY  = %tab[table_id].t_ttab.t_oart.t_dY
%tab[dst].t_ttab.t_oart.t_dZ  = %tab[table_id].t_ttab.t_oart.t_dZ
%tab[dst].t_ttab.t_oart.t_dEC = %tab[table_id].t_ttab.t_oart.t_dEC
%tab[dst].t_ttab.t_oart.t_dXx = %tab[table_id].t_ttab.t_oart.t_dXx
%tab[dst].t_ttab.t_oart.t_dYy = %tab[table_id].t_ttab.t_oart.t_dYy

isAngleDone = 0
IF (isTubeY == 0) THEN
    ;// tube axis is X
    x = acquireX

    z = ze
    c = 0
    IF (((cycleDebug > 0) || !isAngleDone) && isFlat[2]) THEN
        y = u[1] + border
        RPT .acquire_a, .acquire_z, 1
        pLi = y
        pLj = Vacq_z
        y = u[2] - border
        RPT .acquire_a, .acquire_z, 1
        pRi = y
        pRj = Vacq_z
        pC = (pLj + pRj) / 2
        isAngleDone = 1
    ELSE
        y = 0.0
        RPT .acquire_a, .acquire_z, 1
        pC = Vacq_z
    ENDIF
    p[2] = pC

    y = ye
    c = 90
    IF (((cycleDebug > 1) || !isAngleDone) && isFlat[3]) THEN
        z = v[2] - border
        RPT .acquire_a, .acquire_z, 1
        pLi = z
        pLj = Vacq_y
        z = v[3] + border
        RPT .acquire_a, .acquire_z, 1
        pRi = z
        pRj = Vacq_y
        pC = (pLj + pRj) / 2
        isAngleDone = 1
    ELSE
        z = 0.0
        RPT .acquire_a, .acquire_z, 1
        pC = Vacq_y
    ENDIF
    p[3] = pC

    z = zs
    c = 180
    IF (((cycleDebug > 2) || !isAngleDone) && isFlat[0]) THEN
        y = u[3] - border
        RPT .acquire_a, .acquire_z, 1
        pLi = y
        pLj = Vacq_z
        y = u[0] + border
        RPT .acquire_a, .acquire_z, 1
        pRi = y
        pRj = Vacq_z
        pC = (pLj + pRj) / 2
        isAngleDone = 1
    ELSE
        y = 0.0
        RPT .acquire_a, .acquire_z, 1
        pC = Vacq_z
    ENDIF
    p[0] = pC

    y = ys
    c = 270
    IF (((cycleDebug > 3) || !isAngleDone) && isFlat[1]) THEN
        z = v[0] + border
        RPT .acquire_a, .acquire_z, 1
        pLi = z
        pLj = Vacq_y
        z = v[1] - border
        RPT .acquire_a, .acquire_z, 1
        pRi = z
        pRj = Vacq_y
        pC = (pLj + pRj) / 2
        isAngleDone = 1
    ELSE
        z = 0.0
        RPT .acquire_a, .acquire_z, 1
        pC = Vacq_y
    ENDIF
    p[1] = pC

    errorY = (p[3] + p[1]) / 2
    errorZ = (p[2] + p[0]) / 2
    errorX = 0.0
    sizeY  = p[3] - p[1]
    sizeZ  = p[2] - p[0]
    sizeX  = 0.0

    IF (!isAngleDone) THEN
        errorA = 0.0
    ELSE
        errorA = ATAN((pRj - pLj) / ABS(pRi - pLi))
        sizeY = sizeY * COS(errorA)
        sizeZ = sizeZ * COS(errorA)
    ENDIF
    errorB = 0.0
    ;// apply corrections
    IF (!fSimul) THEN
        SYN
        ;dst = table_id
        G153
        tmp[1] = COS(-errorA) * errorY - SIN(-errorA) * errorZ
        tmp[2] = SIN(-errorA) * errorY + COS(-errorA) * errorZ
        %tab[dst].t_ttab.t_oart.t_dXx = %tab[dst].t_ttab.t_oart.t_dXx - tmp[2]
        %tab[dst].t_ttab.t_oart.t_dYy = %tab[dst].t_ttab.t_oart.t_dYy + tmp[1]
        %tab[dst].t_ttab.t_oart.t_dEC = %tab[dst].t_ttab.t_oart.t_dEC + errorA
        G152
        G178 C(pl_add1_c - errorA)
    ENDIF
ELSE
    ;// tube axis is Y
    y = acquireY

    z = ze
    c = 0
    IF (((cycleDebug > 0) || !isAngleDone) && isFlat[3]) THEN
        x = v[2] - border
        RPT .acquire_a, .acquire_z, 1
        pLi = x
        pLj = Vacq_z
        x = v[3] + border
        RPT .acquire_a, .acquire_z, 1
        pRi = x
        pRj = Vacq_z
        pC = (pLj + pRj) / 2
        isAngleDone = 1
    ELSE
        x = 0.0
        RPT .acquire_a, .acquire_z, 1
        pC = Vacq_z
    ENDIF
    p[3] = pC

    x = xs
    c = 90
    IF (((cycleDebug > 1) || !isAngleDone) && isFlat[0]) THEN
        z = u[3] - border
        RPT .acquire_a, .acquire_z, 1
        pLi = z
        pLj = Vacq_x
        z = u[0] + border
        RPT .acquire_a, .acquire_z, 1
        pRi = z
        pRj = Vacq_x
        pC = (pLj + pRj) / 2
        isAngleDone = 1
    ELSE
        z = 0.0
        RPT .acquire_a, .acquire_z, 1
        pC = Vacq_x
    ENDIF
    p[0] = pC

    z = zs
    c = 180
    IF (((cycleDebug > 2) || !isAngleDone) && isFlat[1]) THEN
        x = v[0] + border
        RPT .acquire_a, .acquire_z, 1
        pLi = x
        pLj = Vacq_z
        x = v[1] - border
        RPT .acquire_a, .acquire_z, 1
        pRi = x
        pRj = Vacq_z
        pC = (pLj + pRj) / 2
        isAngleDone = 1
    ELSE
        x = 0.0
        RPT .acquire_a, .acquire_z, 1
        pC = Vacq_z
    ENDIF
    p[1] = pC

    x = xe
    c = 270
    IF (((cycleDebug > 3) || !isAngleDone) && isFlat[2]) THEN
        z = u[1] + border
        RPT .acquire_a, .acquire_z, 1
        pLi = z
        pLj = Vacq_x
        z = u[2] - border
        RPT .acquire_a, .acquire_z, 1
        pRi = z
        pRj = Vacq_x
        pC = (pLj + pRj) / 2
        isAngleDone = 1
    ELSE
        z = 0.0
        RPT .acquire_a, .acquire_z, 1
        pC = Vacq_x
    ENDIF
    p[2] = pC

    errorZ = (p[3] + p[1]) / 2
    errorX = (p[2] + p[0]) / 2
    errorY = 0.0
    sizeZ  = p[3] - p[1]
    sizeX  = p[2] - p[0]
    sizeY  = 0.0

    IF (!isAngleDone) THEN
        errorB = 0.0
    ELSE
        errorB = ATAN((pRj - pLj) / ABS(pRi - pLi))
        sizeZ = sizeZ * COS(errorB)
        sizeX = sizeX * COS(errorB)
    ENDIF
    errorA = 0.0
    ;// apply corrections
    IF (!fSimul) THEN
        SYN
        ;dst = table_id
        G153
        tmp[0] = COS(-errorB) * errorZ - SIN(-errorB) * errorX
        tmp[1] = SIN(-errorB) * errorZ + COS(-errorB) * errorX
        %tab[dst].t_ttab.t_oart.t_dXx = %tab[dst].t_ttab.t_oart.t_dXx + tmp[1]
        %tab[dst].t_ttab.t_oart.t_dYy = %tab[dst].t_ttab.t_oart.t_dYy - tmp[0]
        %tab[dst].t_ttab.t_oart.t_dEC = %tab[dst].t_ttab.t_oart.t_dEC + errorB
        G152
        G178 C(pl_add1_c - errorB)
    ENDIF
ENDIF

G173

gTravT=-1
; SOLO CON MONOTESTA !!!

;G806 A11 T(sav_gTravT) N1 H(gTravH) D(gTravD) E(gTravE) S(gTravS)

G806 A11 T3 N1 H1 D1 E1 S(workpiece_safe_dist)
gOptimEnableG806 = 0

SYN
IF( (!%gPlc0.29) && (!%PlcOp0.2) ) THEN ; If not 1000.pgm and not DRYRUN
    IF( %M107.1 ) M497  ;Enable GASES
ENDIF

MSGOUT
F(saveF)
RET


;******************************************************************************
.acquire_a
    ;// approach
    G180 X(x) Y(y) Z(z) B0 C(c)
    IF (isTubeY == 0) THEN
        G1000 X(kine_x) Y(kine_y) B(kine_b) C(kine_c) U(acquireU)
    ELSE
        G1000 X(kine_x) Y(kine_y) B(kine_b) C(kine_c) V(acquireV)
    ENDIF

    ;// V-ACQUIRE
    ;// TODO: PROBE CYCLE (uses: overTravelV)

    ?%CalPipe[0].General[3] = 1                  ; index to communicate in laser touch the setpoint for the calibration

    G180 P1 X(x) Y(y) Z(z) C(c)

    ?%UnitWork.uxh[0].a_x = kine_x
    ?%UnitWork.uxh[0].a_y = kine_y
    ?%UnitWork.uxh[0].a_z = kine_z + %UnitWork.uxh[0].uxh_Thickness + DistFromPiece;
    ?%UnitWork.uxh[0].touch_mode = 1
    ?%UnitWork.uxh[0].regol_mode = 1

    SYN
    ; Relative Coordinates
    tx = x
    ty = y
    tz = z

    ti = 0
    tj = SIN(c)
    tk = COS(c)
    EI(ti) EJ(tj) EK(tk)
    G152

    JSR "laser_start.cfs"

    SYN
    touch_epsilon = (%vrtc1.VrMon_Q_Flt_Q / 1000)

    ?%CalPipe[0].General[3] = 0                ; index to communicate in laser touch the setpoint for the calibration

    JSR "laser_stop.cfs"

    ;// Ricerca blocco NON in corso e NON verify|grafica ($ricgrp)
    ;;;IF ( ((!(%cn[0].rc[8].8)) || (%cn[0].rc[8].15)) && !%cn[WHO()].rc[0].21 ) JSR "Sel_Y3Z3.cfs"

    ;Pipe calibration with touching
    IF( %LSRPlcOp0.10 == 1 ) THEN

        G153

        ;Disab filter
        ?%LsIso15.2 = 1 ;
        ?%LsIso16.2 = 1 ;
        G4 F0.1         ;

        ;Disable tip touch
        ?%LsIso17.0 = 1

        DECTRJ=4000     ;
        JRKTRJ=0        ;

        ;//Parametri per _singolo e _singfc
        ; 0x10              ;vmax presente
        ; 0x04              ;forza vout  = 0
        ; 0x08              ;forza vout != 0
        ; 0x01              ;quota assoluta
        ; 2                 ;indietro
        ; 1                 ;avanti
        _singfc( ( 0x10 | 0x08 ), Z, 2, 200, 0, "%LsPlc11.8", 1 )

        ;Enab filter
        ?%LsIso15.2 = 0 ;
        ?%LsIso16.2 = 0 ;
        G4 F0.1         ;

        DECTRJ=%cn[WHO()].pc7
        JRKTRJ=%cn[WHO()].pc16

        _singfc( ( 0x10 | 0x04 ), Z, 1, 200, 0, "%LsPlc11.8", 0 )
        G4 F0.2

        ;Enable tip touch
        ?%LsIso17.0 = 0

        SYN
        z_abs = GET(Z)
        touch_epsilon = z_abs - %UnitWork.uxh[0].a_z + DistFromPiece
        G10 G0 Z(QCALC(Z))
        G152

    ENDIF

    MSGOUT "touch_epsilon= " NPREC(touch_epsilon, 0.001)

    IF (fGraph) G2805 C12 X(x) Y(y) Z(z)

    G180 P1 X(x) Y(y) Z(z)

    G180 D1 P1 Z(kine_z + touch_epsilon)
    Vacq_x = kine_x
    Vacq_y = kine_y
    Vacq_z = kine_z

    ;// leave
    G153 G0 Z(optimized_lift)
.acquire_z
;******************************************************************************
