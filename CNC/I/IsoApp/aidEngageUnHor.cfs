 : aidEngageUnHor
;============================================================================
; aidEngageUnHor - Initialization G4011 T36 with proper supports positions
;============================================================================
IF (%cn[WHO()].rc[0].21) RET
IF (CouplingFollowEnUnHor == 1) RET 

; Different Horizontal Support Travel 
L_COM_PrkPos =  %ax[AXIDX(7,Z)].pa22 / 1000

DBL hlifter_A[10], hlifter_D[10]  
DBL velAxisx = %ax[AXIDX(5,X)].pa9
DBL filterT1Rate = velAxisx / ABS(L_COM_PrkPos) 
DBL velAddValue = velAxisx 
										        
;//Blending filter time constants               
DBL max_q0 = ABS(L_COM_PrkPos)                  ;//max slave displacement [mm]
DBL max_q1 = velAddValue/60                     ;//max slave velocity [mm/min]
DBL max_q2 = 5000                               ;//max slave acceleration [mm/s^2]
DBL max_q3 = 50000                              ;//max slave jerk [mm/s^3]
	
DBL filterT1 = max_q0/max_q1	
DBL filterT2 = max_q1/max_q2                    ;//TODO: add 2x for direction change
DBL filterT3 = max_q2/max_q3                    ;//2x added for triangular velocity

RPT .UngearAll_Start, .UngearAll_End, 1
 
;============================================================================
; Bring each support to the position to init (CN7) 
;============================================================================ 
; when loader is running init unloader with parking 
; ?%SUPPORTS_SYSTEM.boolean1.30 = 1
; G4 F0.05
; WAITBIT( "%SUPPORTS_SYSTEM.boolean1.30", 0 )

;============================================================================
;// G4011 T36 (motion blending) 
;// Following registers are used:
;//       %ax[slave].rgau0    G4011 T36: blendSwitch      input  [0|1]
;//       %ax[slave].rgau1    G4011 T36: addValue         input  [um]
;//       %ax[slave].rgau2    G4011 T36: blendState       output [0..1]
;//       %ax[slave].rgau3    G4011 T36: addValueM        input  [um]
;//       %ax[slave].rgau4    G4011 T36: actualAddValue   output [um] _3
;//       %ax[slave].rgau5    G4011 T36: actualAddValueM  output [um] _3
;// NOTE: blendSwitch and addValue are reset at G4011 T36 time and should be
;//       written by the PLC afterwards (using VAR_IN_OUT).
;// 
;//       [G<addValueVelM> H<accTimeM> I<jerkTimeM>] _3
;//       [J<addValueVel> K<accTime> L<jerkTime>] _3
;// 
;============================================================================

?%gIso39.3 = 0      ; Disable blendSwitch PLC writes
?%gIso39.4 = 1      ; =0 parking, =1 follow 

;// Check HoldZxSupp from PLC
RPT .Chk_HoldZxSupp_Start, .Chk_HoldZxSupp_End, 1

SYN
G153
IF (AEXISTS(7,Z)) G4011 T36 A(-filterT1Rate) B(filterT2) C(filterT3) F(!hlifter_A[2]) M(-1) N(-1) D(hlifter_D[2]) S(AXIDX(7,Z)) G(velAddValue) H(filterT2) I(filterT3) J(velAddValue) K(filterT2) L(filterT3)
IF (AEXISTS(7,U)) G4011 T36 A(-filterT1Rate) B(filterT2) C(filterT3) F(!hlifter_A[3]) M(-1) N(-1) D(hlifter_D[3]) S(AXIDX(7,U)) G(velAddValue) H(filterT2) I(filterT3) J(velAddValue) K(filterT2) L(filterT3)
IF (AEXISTS(7,V)) G4011 T36 A(-filterT1Rate) B(filterT2) C(filterT3) F(!hlifter_A[4]) M(-1) N(-1) D(hlifter_D[4]) S(AXIDX(7,V)) G(velAddValue) H(filterT2) I(filterT3) J(velAddValue) K(filterT2) L(filterT3)
IF (AEXISTS(7,W)) G4011 T36 A(-filterT1Rate) B(filterT2) C(filterT3) F(!hlifter_A[5]) M(-1) N(-1) D(hlifter_D[5]) S(AXIDX(7,W)) G(velAddValue) H(filterT2) I(filterT3) J(velAddValue) K(filterT2) L(filterT3)
G152                                                                                     
G4099

?%BLEND_VEL.filTRate[3] = filterT1Rate * 1000
?%BLEND_VEL.velAddVal[3] = velAddValue * 1000

?%gIso39.3 = 1      ; =0 parking, =1 follow (Horizontal Sup)
?%gIso39.4 = 1      ; Enable blendSwitch PLC writes (Horizontal Sup)

CouplingFollowEnUnHor = 1

RET

.UngearAll_Start
   G153
   IF (AEXISTS(7,Z)) G4005 S(AXIDX(7,Z))
   IF (AEXISTS(7,U)) G4005 S(AXIDX(7,U))
   IF (AEXISTS(7,V)) G4005 S(AXIDX(7,V))
   IF (AEXISTS(7,W)) G4005 S(AXIDX(7,W))
   G152
   G4099
.UngearAll_End

.Chk_HoldZxSupp_Start
   iter=2
   SYN
   WHILE( iter <= 5 )
        IF( ists_7cn[iter] ) hlifter_A[iter] = ABS(%ax[83+iter].ra24 / 1000) > 15  
        IF( ists_7cn[iter] ) hlifter_D[iter] = IFEXP( hlifter_A[iter] == 0, 0, L_COM_PrkPos)
   	    iter = iter + 1
   ENDW
.Chk_HoldZxSupp_End



 