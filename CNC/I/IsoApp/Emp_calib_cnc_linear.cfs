:  
;******************************************************************************
;   CALIB_CNC_LINEAR.CFS
;   ESAutomotion
;   LASER machine
;******************************************************************************
INCLUDE "var_usr.cfs"

DBL ABSINC  = 0x01
DBL VOUT0   = 0x04
DBL VOUT    = 0x08
DBL VMAX    = 0x10

DBL VHIGH  = 2000
DBL VLOW   = 200
DBL LevelE = 0                     ; [(Normale close)  Aspetta il segnale a 0 per uscire dal comando]
DBL LevelS = 1                     ; [(Normale open)   Aspetta il segnale a 1 per uscire dal comando]
DBL Z_FEED = 10000
DBL z_touch, zz
DBL z_comp = %Cost_User[15]/1000    ; Compensazione linearizzazione capacitivo con diametro nozzle 
DBL z_lift = 0 
DBL lstLowVal = 0
DBL indloop = 0
 
DBL Speed = 5000            ; Feed per G1 posiz. assi 
DBL Attesa = 0.2            ; Attesa tra una posizione e la successiva
DBL StepZ = 0 
DBL cost = 0  
DBL pdsel = 41  
DBL sel                     ; offset calibration tables (for head1 or head2)
DBL angle = 0
DBL non_touchlinear = 0
          
?%LsIso10.0 = 0                    ;ISO said Sensor Calibration OK

$ CALCULATE DATA FOR CAPACITIVE BEVEL LINEARIZATION...
SYN
?%C26.2=1

IF ( %UnitWork.uxh0.uxh_gTravT == 1 ) sel = 0
IF ( %UnitWork.uxh1.uxh_gTravT == 2 ) sel = 7     

IF( %M33 ) z = 80
;G153 G1 Z((MaxQta_Z)-10) F10000
;G153 G0 A0 B0

SYN
G172 T1 H1 D1       ; Select the head to work with tcp coordinates
G180 D1             ; Convert in absolute coordinates the tip touch points (tcp coordinates)
x = kine_x
y = kine_y

G180 X(x) Y(y) Z(touch_pos+(%LSRCostK[31]/1000)) A(0) B(0)     
G153 G1 X(kine_x) Y(kine_y) Z(kine_z) A(0) B(0) F(Speed)
zz = kine_z

;**************************************
;   bevel 0
;**************************************
angle = 0
z = touch_pos
pdsel = 41  
RPT .FUN_ACQ_START, .FUN_ACQ_END, 1

;**************************************
;   bevel 15
;**************************************
SYN
IF( %TsCalib[1].enab == 1 ) THEN
    angle = %TsCalib[1].targ_b_axis
    RPT .FUN_PROBING_S, .FUN_PROBING_E, 1
    z = z_touch
    pdsel = 42  
    RPT .FUN_ACQ_START, .FUN_ACQ_END, 1
ENDIF

;**************************************
;   bevel 30
;**************************************
SYN
IF( %TsCalib[2].enab == 1 ) THEN
    angle = %TsCalib[2].targ_b_axis
    RPT .FUN_PROBING_S, .FUN_PROBING_E, 1
    z = z_touch
    pdsel = 43  
    RPT .FUN_ACQ_START, .FUN_ACQ_END, 1
ENDIF

;**************************************
;   bevel 45
;**************************************
SYN
IF( %TsCalib[3].enab == 1 ) THEN
    angle = %TsCalib[3].targ_b_axis
    RPT .FUN_PROBING_S, .FUN_PROBING_E, 1
    z = z_touch
    pdsel = 44
    RPT .FUN_ACQ_START, .FUN_ACQ_END, 1
ENDIF
   
   
;**************************************
?%ui0.10 = 1            ; calculate the graph coefficients, command for the interface
SYN 
AWAIT(%ui33.11)         ; wait interface receive the commands
?%ui0.10 = 0            ; calculate the graph coefficients, command for the interface

?%C26.2=0       
         
SYN
G180 X(x) Y(y) Z(touch_pos+(%LSRCostK[31]/1000)) A(0) B(0)  
G153 G1 Z(kine_z) F(Speed) 
G153 G1 X(kine_x) Y(kine_y) Z(kine_z) A(0) B(kine_b) F(Speed)

G153 G0 Z((MaxQta_Z)-10) 

RET


;**************************************
.FUN_ACQ_START

z_lift = ABS(SIN(angle/1000)) * 0.5 * ABS(z_comp)

FOR cost=0 TO 19

    IF( cost == 0 ) THEN
        ?%pd_splines[pdsel + sel].pdh_X[cost] = 0
        ?%pd_splines[pdsel + sel].pdh_Y[cost] = 0
    ELSE
        SYN
        IF( %pd_splines[pdsel + sel].pdh_Y[cost] == 0 ) BREAK

        %pd_splines[pdsel + sel].pdh_nPoints = cost+1  

        StepZ = %pd_splines[pdsel + sel].pdh_Y[cost]
		
        SYN
		IF( (z_lift <= StepZ) && (lstLowVal == 1) ) THEN
		    FOR indloop =0 TO cost-1
			    IF( sel == 0) ?%pd_splines[pdsel + sel].pdh_X[indloop] = %pd_splines[pdsel + sel].pdh_X[cost-1] 
                IF( sel == 7) ?%pd_splines[pdsel + sel].pdh_X[indloop] = %pd_splines[pdsel + sel].pdh_X[cost-1] 
			ENDFOR
		ENDIF
		
		; In case of bevel, tip-touch case with height not 0
		IF( z_lift <= StepZ ) THEN
            G153 G1 Z(z + StepZ) F(Speed) 
			lstLowVal = 0
		ELSE	
			lstLowVal = 1
        ENDIF
		
        SYN
        ; ### Not in SIMulation
        IF( %M33 == 0 ) THEN
            IF( sel == 0) ?%pd_splines[pdsel + sel].pdh_X[cost] = %C120 
            IF( sel == 7) ?%pd_splines[pdsel + sel].pdh_X[cost] = %C132
        ELSE
            ?%pd_splines[pdsel + sel].pdh_X[cost] = (4095 * (%pd_splines[pdsel + sel].pdh_Y[cost]))/ (%LSRCostK[31]/1000)
        ENDIF
    ENDIF
ENDFOR

.FUN_ACQ_END


;**************************************
.FUN_PROBING_S

; Orienta gli assi con il TCP
SYN
IF( non_touchlinear == 1 ) THEN
    z_lift = ABS(SIN(angle/1000)) * 0.5 * ABS(z_comp)
    G180 X(x) Y(y) Z(touch_pos+(%LSRCostK[31]/1000)) A(0) B(0)     
    G153 G1 X(kine_x) Y(kine_y) Z(kine_z) A(0) B(0) F(Speed)
ELSE
    G180 X(x) Y(y) Z(zz) A(0) B(angle/1000)     
    G153 G1 X(kine_x) Y(kine_y) Z(kine_z) A(0) B(kine_b) F(Speed)
    ; Iterative angle calibration velocity reducer
    IF(angle>0) VLOW = VLOW * 0.7
ENDIF

;Disable tip touch        
?%LsIso17.0 = 1

; ### Not in SIMulation
IF( %M33 == 0 ) THEN
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ;Tastatura
    G153
    IF( %LSRPlcOp0.20 ) THEN        ; FAR INPUT management enabled
    _singfc( ( VMAX | VOUT0 ), Z, 2, VHIGH, 0, "%EmConfig.Far_signal.0 ", LevelE )  ;Far
    ENDIF

    _singfc( ( VMAX | VOUT0 ), Z, 2, VLOW, 0, "%C31.1", LevelS )  ; Aspetta il segnale alto per uscire
    _singfc( ( VMAX | VOUT0 ), Z, 1, VLOW/4, 0, "%C31.1", LevelE )  ; Aspetta il segnale basso per uscire
    SYN
    kine_z = GET(Z)
    z_touch = kine_z
    G10 G0 Z(QCALC(Z))
    G152	
ELSE    
    G153 G1 F(Z_FEED) Z(10) ;Posizionamento a 10mm fisso (SOLO per TEST)
    z_touch = 0
ENDIF

G153

;Enable tip touch        
?%LsIso17.0 = 0

IF( non_touchlinear == 1 ) THEN
    G153 G1 F(Speed) Z(z_touch + z_lift)
    G180 X(x) Y(y) Z(z_touch + z_lift) A(0) B(angle/1000) 
	G153 G1 X(kine_x) Y(kine_y) Z(kine_z) A(0) B(kine_b) F(Speed)
	z_touch = z_touch + z_lift
ENDIF

.FUN_PROBING_E
