:

INCLUDE "var_usr.cfs"

DBL i = 0                           ;
DBL Speed = 500                   ; Velocita' di discesa Z2
DBL Attesa = 0.3                   ; Attesa tra un posiz e l'altro
DBL middleStep = 0
DBL feedB = 300
DBL cost = 0
DBL sel                            ; offset calibration tables
DBL angCoef
DBL non_touchlinear = 0
DBL z_lift = 0
DBL angle = 0
DBL z_comp = %Cost_User[15]/1000    ; Compensazione linearizzazione capacitivo con diametro nozzle
DBL ABSINC  = 0x01
DBL VOUT0   = 0x04
DBL VOUT    = 0x08
DBL VMAX    = 0x10
DBL LevelE = 0                     ; [(Normale close)  Aspetta il segnale a 0 per uscire dal comando]
DBL LevelS = 1                     ; [(Normale open)   Aspetta il segnale a 1 per uscire dal comando]
DBL VHIGH  = 2000
DBL VLOW   = 200
DBL z_touch, zz
DBL StepZ = 0 
DBL lstLowVal = 0
DBL indloop = 0
DBL Z_FEED = 1000
DBL pdsel = 41  

DBL Debug = 0

?%LsIso10.0 = 0                    ;ISO said Sensor Calibration OK

SYN
?%C26.0=1                           ; Calibration control running
?%C26.2=1                           ; Linearizzazione capacitivo in esecuzione


IF ( %UnitWork.uxh0.uxh_gTravT == 1 ) sel = 0
IF ( %UnitWork.uxh1.uxh_gTravT == 2 ) sel = 7

IF( %M33 ) z = 80   ; %M33 : Simulation

SYN
G172 T1 H1 D1       ; Select the head to work with tcp coordinates
G180 D1             ; Convert in absolute coordinates the tip touch points (tcp coordinates)
x = kine_x
y = kine_y

G180 X(x) Y(y) Z(touch_pos+(%LSRCostK[31]/1000)) A(0) B(0)     
G153 G1 X(kine_x) Y(kine_y) Z(kine_z) A(0) B(0) F(Speed)
zz = kine_z

;**************************************
;   bevel 0
;**************************************
angle = 0
z = touch_pos
pdsel = 41  
RPT .FUN_ACQ_START, .FUN_ACQ_END, 1

;**************************************
;   bevel 15
;**************************************
SYN
IF( %TsCalib[1].enab == 1 ) THEN
    angle = %TsCalib[1].targ_b_axis
    RPT .FUN_PROBING_S, .FUN_PROBING_E, 1       ; Redo the probing in order to set the the nozzle at proper height
    z = z_touch
    pdsel = 42  
    RPT .FUN_ACQ_START, .FUN_ACQ_END, 1
ENDIF

;**************************************
;   bevel 30
;**************************************
SYN
IF( %TsCalib[2].enab == 1 ) THEN
    angle = %TsCalib[2].targ_b_axis
    RPT .FUN_PROBING_S, .FUN_PROBING_E, 11       ; Redo the probing in order to set the the nozzle at proper height
    z = z_touch
    pdsel = 43  
    RPT .FUN_ACQ_START, .FUN_ACQ_END, 1
ENDIF

;**************************************
;   bevel 45
;**************************************
SYN
IF( %TsCalib[3].enab == 1 ) THEN
    angle = %TsCalib[3].targ_b_axis
    RPT .FUN_PROBING_S, .FUN_PROBING_E, 11       ; Redo the probing in order to set the the nozzle at proper height
    z = z_touch
    pdsel = 44
    RPT .FUN_ACQ_START, .FUN_ACQ_END, 1
ENDIF



?%ui0.10 = 1            ; calculate the graph coefficients, command for the interface
SYN
AWAIT(%ui33.11)         ; wait interface receive the commands
?%ui0.10 = 0            ; calculate the graph coefficients, command for the interface

?%C26.0=0                           ; Calibration control running
?%C26.2=0                           ; Linearizzazione capacitivo in esecuzione

SYN
G180 X(x) Y(y) Z(touch_pos+(%LSRCostK[31]/1000)) A(0) B(0)  
G153 G1 Z(kine_z) F(Speed) 
G153 G1 X(kine_x) Y(kine_y) Z(kine_z) A(0) B(kine_b) F(Speed)

G153 G0 Z((MaxQta_Z)-10) 

RET

;**************************************
.FUN_PROBING_S

; Orienta gli assi con il TCP
SYN
IF( non_touchlinear == 1 ) THEN
    z_lift = ABS(SIN(angle/1000)) * 0.5 * ABS(z_comp)
    G180 X(x) Y(y) Z(touch_pos+(%LSRCostK[31]/1000)) A(0) B(0)
    G153 G1 X(kine_x) Y(kine_y) Z(kine_z) A(0) B(0) F(Speed)
ELSE
    G180 X(x) Y(y) Z(zz) A(0) B(angle/1000)
    G153 G1 X(kine_x) Y(kine_y) Z(kine_z) A(0) B(kine_b) F(Speed)
    ; Iterative angle calibration velocity reducer
    IF(angle>0) VLOW = VLOW * 0.7
ENDIF

;Disable tip touch
?%LsIso17.0 = 1

; ### Not in SIMulation
IF( %M33 == 0 ) THEN
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ;Tastatura
    G153
    IF( %LSRPlcOp0.20 ) THEN        ; FAR INPUT management enabled
    _singfc( ( VMAX | VOUT0 ), Z, 2, VHIGH, 0, "%C31.0 ", LevelE )  ;Far
    ENDIF

    _singfc( ( VMAX | VOUT0 ), Z, 2, VLOW, 0, "%C31.1", LevelS )  ; Aspetta il segnale alto per uscire
    _singfc( ( VMAX | VOUT0 ), Z, 1, VLOW/4, 0, "%C31.1", LevelE )  ; Aspetta il segnale basso per uscire
    SYN
    kine_z = GET(Z)
    z_touch = kine_z
    G10 G0 Z(QCALC(Z))
    G152
ELSE
    G153 G1 F(Z_FEED) Z(10) ;Posizionamento a 10mm fisso (SOLO per TEST)
    z_touch = 0
ENDIF

G153

;Enable tip touch
?%LsIso17.0 = 0

IF( non_touchlinear == 1 ) THEN
    G153 G1 F(Speed) Z(z_touch + z_lift)
    G180 X(x) Y(y) Z(z_touch + z_lift) A(0) B(angle/1000)
	G153 G1 X(kine_x) Y(kine_y) Z(kine_z) A(0) B(kine_b) F(Speed)
	z_touch = z_touch + z_lift
ENDIF

.FUN_PROBING_E

;**************************************
.FUN_ACQ_START

z_lift = ABS(SIN(angle/1000)) * 0.5 * ABS(z_comp)

FOR cost=0 TO 19

    IF( cost == 0 ) THEN
        ?%pd_splines[pdsel + sel].pdh_X[cost] = 0
        ?%pd_splines[pdsel + sel].pdh_Y[cost] = 0
    ELSE
        SYN
        IF( %pd_splines[pdsel + sel].pdh_Y[cost] == 0 ) BREAK

        %pd_splines[pdsel + sel].pdh_nPoints = cost+1  

        StepZ = %pd_splines[pdsel + sel].pdh_Y[cost]
		
        SYN
		IF( (z_lift <= StepZ) && (lstLowVal == 1) ) THEN
		    FOR indloop =0 TO cost-1
			    IF( sel == 0) ?%pd_splines[pdsel + sel].pdh_X[indloop] = %pd_splines[pdsel + sel].pdh_X[cost-1] 
                IF( sel == 7) ?%pd_splines[pdsel + sel].pdh_X[indloop] = %pd_splines[pdsel + sel].pdh_X[cost-1] 
			ENDFOR
		ENDIF
		
		; In case of bevel, tip-touch case with height not 0
		IF( z_lift <= StepZ ) THEN
            G153 G1 Z(z + StepZ) F(Speed) 
			lstLowVal = 0
		ELSE	
			lstLowVal = 1
        ENDIF
		
        SYN
        ; ### Not in SIMulation
        IF( %M33 == 0 ) THEN
            IF( sel == 0) ?%pd_splines[pdsel + sel].pdh_X[cost] = %C120 
            IF( sel == 7) ?%pd_splines[pdsel + sel].pdh_X[cost] = %C132
        ELSE
            ?%pd_splines[pdsel + sel].pdh_X[cost] = (4095 * (%pd_splines[pdsel + sel].pdh_Y[cost]))/ (%LSRCostK[31]/1000)
        ENDIF
    ENDIF
ENDFOR

.FUN_ACQ_END





; LEGACY - Don't even try looking at it...
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; bevel acquire 0 degree

?%pd_splines[41 + sel].pdh_nPoints = 20

; G1 Z(z+(%LSRCostK[31]/1000)) F10000
; G1 X(x) Y(y) A0 B0 F(feedB)
SYN
MSGOUT "z " z



G180 D1 Z(z)   ;TRASFORMA DA ASSOLUTA A RELATIVA

; IF ( %config_machine26 == 1 ) z = kine_z
z = kine_z
x = kine_x
y = kine_y

; SYN
; MSGOUT "z " z
; M0

G1 Z(z+(%LSRCostK[31]/1000)) F200

G1 X(x) Y(y) A0 B0 F(feedB)


?%pd_splines[41 + sel].pdh_X[0] = 0
;  ?%pd_splines[41 + sel].pdh_Y[0] = 0

i = (%LSRCostK[31]/1000)
cost = 19

WHILE (cost > 0)

  IF (Debug == 1 ) M0

    ; 20 mm range

    IF ((%LSRCostK[31]/1000) == 20 ) THEN

        IF (Debug == 1 ) M0

        SYN
        IF ( cost == 19 ) middleStep = i


        IF (( cost > 0) && ( cost <= 9 )) THEN

            IF (Debug == 1 ) M0

            i = i - 0.5
            middleStep = i
        ENDIF

        IF  (( cost > 9 ) && (cost < 13)) THEN

            IF (Debug == 1 ) M0

            i = i - 1
            middleStep = i
        ENDIF

        IF (( cost >= 13) && ( cost < 19 )) THEN

            IF (Debug == 1 ) M0

            IF ( cost == 18) THEN

                IF (Debug == 1 ) M0

                i = 18
            ELSE

                i = i - 2
            ENDIF

            middleStep = i
        ENDIF

    ENDIF

    ; 10mm range

    IF ((%LSRCostK[31]/1000) == 10 ) THEN

        SYN
        IF ( cost == 18 ) i = i - 1
        middleStep = i

        IF (( cost > 0) && ( cost < 18 )) THEN
            i = i - 0.5
            middleStep = i
        ENDIF

    ENDIF

    IF (Debug == 1 ) M0
    G1 X(x) Y(y) Z(z + middleStep) F(Speed)

    G4 F(Attesa)
    SYN
    IF( sel == 0) ?%pd_splines[41 + sel].pdh_X[cost] = %C120
    IF( sel == 7) ?%pd_splines[41 + sel].pdh_X[cost] = %C132
    ?%pd_splines[41 + sel].pdh_Y[cost] = middleStep

    cost = cost - 1

ENDWHILE

SYN
angCoef = (%pd_splines[41 + sel].pdh_Y2 - %pd_splines[41 + sel].pdh_Y1) / (%pd_splines[41 + sel].pdh_X2 - %pd_splines[41 + sel].pdh_X1)
?%pd_splines[41 + sel].pdh_Y0 = %pd_splines[41 + sel].pdh_Y1 - (angCoef * %pd_splines[41 + sel].pdh_X1)


IF ((!%LSRPlcOp1.29)) JMPF .noBevelCalib

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; bevel acquire 15 degree

?%pd_splines[42 + sel].pdh_nPoints = 20
;;;;;;?%TabLsr1.L_Tickness = 399500          ; for debug

      G1 Z(z+(%LSRCostK[31]/1000)) F300
      G1 X(x) Y(y) B15 A0 F(feedB)

      ?%pd_splines[42 + sel].pdh_X[0] = 0
    ;  ?%pd_splines[42 + sel].pdh_Y[0] = 0

FOR cost = 19 TO 1        ; in this case i is same with mm
IF (Debug == 1 ) M0
    IF ((cost == 19) && ((%LSRCostK[31]/1000) == 20)) i = 20
    IF ((cost == 18) && ((%LSRCostK[31]/1000) == 20)) i = i-2
    IF ((cost < 18) && ((%LSRCostK[31]/1000) == 20))  i = i-1

    IF ((cost == 19) && ((%LSRCostK[31]/1000) == 10)) i = 10
    IF ((cost < 19) && ((%LSRCostK[31]/1000) == 10))  i = i-0.5

    middleStep = i


   G1 X(x) Y(y) Z(z + middleStep ) F(Speed)

    G4 F(Attesa)
   SYN
   IF( sel == 0) ?%pd_splines[42 + sel].pdh_X[cost] =%C120
   IF( sel == 7) ?%pd_splines[42 + sel].pdh_X[cost] =%C132
   ?%pd_splines[42 + sel].pdh_Y[cost] = i

ENDFOR

SYN
angCoef = (%pd_splines[42 + sel].pdh_Y2 - %pd_splines[42 + sel].pdh_Y1) / (%pd_splines[42 + sel].pdh_X2 - %pd_splines[42 + sel].pdh_X1)
?%pd_splines[42 + sel].pdh_Y0 = %pd_splines[42 + sel].pdh_Y1 - (angCoef * %pd_splines[42 + sel].pdh_X1)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; bevel acquire 30 degree

DBL attempts = 16

?%pd_splines[43 + sel].pdh_nPoints = attempts+1
;;;;?%TabLsr1.L_Tickness = 368500           ; for debug

     G1 Z(z+(%LSRCostK[31]/1000)) F300
     G1 X(x) Y(y) B30 A0 F(feedB)

     ?%pd_splines[43 + sel].pdh_X[0] = 0
    ; ?%pd_splines[43 + sel].pdh_Y[0] = 0


FOR cost = attempts TO 1        ; in this case i is same with mm
IF (Debug == 1 ) M0

    IF ((cost == attempts) && ((%LSRCostK[31]/1000) == 20)) i = 20
    IF ((cost == (attempts-1)) && ((%LSRCostK[31]/1000) == 20)) i = i-2
    IF ((cost < (attempts-1)) && ((%LSRCostK[31]/1000) == 20))  i = i-1

    IF ((cost == (attempts)) && ((%LSRCostK[31]/1000) == 10)) i = 10
    IF ((cost < (attempts)) && ((%LSRCostK[31]/1000) == 10))  i = i-0.5

    middleStep = i

   G1 X(x) Y(y) Z(z + middleStep ) F(Speed)

    G4 F(Attesa)
   SYN
   IF( sel == 0) ?%pd_splines[43 + sel].pdh_X[cost] =%C120
   IF( sel == 7) ?%pd_splines[43 + sel].pdh_X[cost] =%C132
   ?%pd_splines[43 + sel].pdh_Y[cost] = i

ENDFOR

SYN
angCoef = (%pd_splines[43 + sel].pdh_Y2 - %pd_splines[43 + sel].pdh_Y1) / (%pd_splines[43 + sel].pdh_X2 - %pd_splines[43 + sel].pdh_X1)
?%pd_splines[43 + sel].pdh_Y0 = %pd_splines[43 + sel].pdh_Y1 - (angCoef * %pd_splines[43 + sel].pdh_X1)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; bevel acquire 45 degree
attempts=15
IF (%PlcOp0.30) THEN
?%pd_splines[44 + sel].pdh_nPoints = attempts+1
;?%pd_splines[44 + sel].pdh_nPoints = 17
;;;;;;;;;;;;?%TabLsr1.L_Tickness = 320500          ; for debug

     G1 Z(z+(%LSRCostK[31]/1000)) F300
     G1 X(x) Y(y) B45 A0 F(feedB)

     ?%pd_splines[44 + sel].pdh_X[0] = 0
  ;   ?%pd_splines[44 + sel].pdh_Y[0] = 0

FOR cost = (attempts) TO 1             ; in this case i is same with mm
IF (Debug == 1 ) M0
;FOR cost = 16 TO 1             ; in this case i is same with mm

IF ((cost == (attempts)) && ((%LSRCostK[31]/1000) == 20)) i = 20
;IF ((cost == 16) && ((%LSRCostK[31]/1000) == 20)) i = 20
IF ((cost == (attempts-1)) && ((%LSRCostK[31]/1000) == 20)) i = i-2
IF ((cost < (attempts-1)) && ((%LSRCostK[31]/1000) == 20))  i = i-1

IF ((cost == (attempts)) && ((%LSRCostK[31]/1000) == 10)) i = 10
IF ((cost < (attempts)) && ((%LSRCostK[31]/1000) == 10))  i = i-0.5

middleStep = i

G1 X(x) Y(y) Z(z + middleStep ) F(Speed)

G4 F(Attesa)
SYN
IF( sel == 0) ?%pd_splines[44 + sel].pdh_X[cost] =%C120
IF( sel == 7) ?%pd_splines[44 + sel].pdh_X[cost] =%C132
?%pd_splines[44 + sel].pdh_Y[cost] = i

ENDFOR

SYN
angCoef = (%pd_splines[44 + sel].pdh_Y2 - %pd_splines[44 + sel].pdh_Y1) / (%pd_splines[44 + sel].pdh_X2 - %pd_splines[44 + sel].pdh_X1)
?%pd_splines[44 + sel].pdh_Y0 = %pd_splines[44 + sel].pdh_Y1 - (angCoef * %pd_splines[44 + sel].pdh_X1)
ENDIF



.noBevelCalib
;;;;;;?%TabLsr1.L_Tickness = 410000

?%ui0.10 = 1            ; calculate the graph coefficients, command for the interface
SYN
AWAIT(%ui33.11)         ; wait interface receive the commands
?%ui0.10 = 0            ; calculate the graph coefficients, command for the interface

?%C26.0=0                           ; Calibration control running
?%C26.2=0                           ; Linearizzazione capacitivo in esecuzione

G4 F0.1

G1 Z(z+25) F10000
G1 X(x) Y(y) A0 B0 F(feedB)

RET